<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="es" xml:lang="es">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Tarea: Identificar elementos de dise&ntilde;o</title>
<meta content="Task" name="uma.type">
<meta content="identify_design_elements" name="uma.name">
<meta content="Identificar elementos de dise&ntilde;o" name="uma.presentationName">
<meta content="Discipline:rup_analysis_design_discipline:An&aacute;lisis y dise&ntilde;o" name="uma.category">
<meta name="element_type" content="activity">
<meta content="description" name="filetype">
<meta name="role" content="Arquitecto de software">
<link type="text/css" href="./../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../';
					var imgPath = './../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_f6_YwN7DEdmsEI4YDGX2ag", "_qwxC8N7YEdmjRZts2c4ZjQ", "{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}", "{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_kC0pcN7GEdm8G6yT7-Wdqw", "_ydt62NnmEdmO6L4XMImrsA", "{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_qwxC8N7YEdmjRZts2c4ZjQ", "{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}", "{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_IY0NkAISEdqTna4sZVFRow", "_ydt62NnmEdmO6L4XMImrsA", "{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}"]}, {view: "view:_OAq98E7KEduvcvbnLvkXhA", path: ["_OAq98E7KEduvcvbnLvkXhA", "_pTvboE7MEduvcvbnLvkXhA", "{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}", "{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}"]}];
					contentPage.preload(imgPath, backPath, nodeInfo, '', true, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top">
<div id="page-guid" value="{97D7343A-6993-4AB7-8F86-4DAC8C9075C8}"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Tarea: Identificar elementos de dise&ntilde;o</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../images/task.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">En esta tarea se explica cómo se identifican los subsistemas, las clases, las interfaces, los sucesos y las señales.</td>
</tr>
<tr>
<td>Disciplinas: <a href="./../../core.base_rup/disciplines/rup_analysis_design_discipline_29760231.html" guid="_ydt62NnmEdmO6L4XMImrsA">Análisis y diseño</a></td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Objetivo</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a> 
<ul>
    <li>
        <a key="clase" text="perfeccionar clases de análisis" name="XE_class__refining_analysis_classes" id="XE_class__refining_analysis_classes" class="index"></a>Analizar las interacciones de las clases de análisis
        para identificar los elementos de modelo de diseño
    </li>
</ul></td>
</tr>
</table>
</div>
<div class="sectionHeading">Relaciones</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Roles</th><td width="42%" class="sectionTableCell"><span class="sectionTableCellHeading">Realizador principal:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/roles/rup_software_architect_DB0BF177.html" guid="{4AC346F0-E6FC-4D2C-8410-2EDF8DDDC91D}">Arquitecto de software</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">Otras actividades adicionales que realiza:
								</span></td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Entradas</th><td width="42%" class="sectionTableCell"><span class="sectionTableCellHeading">Obligatoria:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/workproducts/rup_analysis_class_DAF7CE03.html" guid="{1E20603F-A5B8-42D5-BDBC-69DCE9C0FCDB}">Clase de an&aacute;lisis</a>
</li>
<li>
<a href="./../../soa.rup_soma/workproducts/soa_service_model_623494B9.html" guid="{E24679B7-19F1-483B-A1F1-578839C43888}">Modelo de servicio</a>
</li>
</ul>
</td><td class="sectionTableCell"><span class="sectionTableCellHeading">Opcional:
								</span>
<ul>
<li>
<a href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Directrices espec&iacute;ficas del proyecto</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_software_architecture_document_C367485C.html" guid="{6F49641A-ED10-47B5-9E5D-3F90A6BF3006}">Documento de arquitectura de software</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_supplementary_specification_F5ACAA22.html" guid="{B16C2941-791C-44E6-B353-354109B5C9DE}">Especificaciones suplementarias</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_analysis_model_76C3B70C.html" guid="{98EA224C-36F6-46E6-AB36-2999382B58B3}">Modelo de an&aacute;lisis</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Modelo de dise&ntilde;o</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Salidas</th><td colspan="2" class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">C&aacute;psula</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_design_class_B33BD5E5.html" guid="{952A9CE9-D5A3-43AC-980D-0B9298F3872E}">Clase de dise&ntilde;o</a>
</li>
<li>
<a href="./../../soa.rup_soma/workproducts/soa_svce_component_E259F3CC.html" guid="{447385A0-E565-4C87-A082-402AF21CA088}">Componente de servicio</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_interface_9816B54F.html" guid="{C6938487-1DAA-4F6A-B3BC-CB99165F0680}">Interfaz</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Modelo de dise&ntilde;o</a>
</li>
<li>
<a href="./../../soa.rup_soma/workproducts/soa_service_model_623494B9.html" guid="{E24679B7-19F1-483B-A1F1-578839C43888}">Modelo de servicio</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_design_package_8376BC8E.html" guid="{80CC5437-F481-487B-A69B-957D9D236D8D}">Paquete de dise&ntilde;o</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_protocol_BEB5FBE1.html" guid="{6E4F4D6F-2934-432C-9335-5537B795F67F}">Protocolo</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_signal_AD16C912.html" guid="{8CA124DA-A80C-45D7-BC65-BA6B4247FF11}">Se&ntilde;al</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html" guid="{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}">Subsistema de dise&ntilde;o</a>
</li>
<li>
<a href="./../../core.base_rup/workproducts/rup_event_741355DE.html" guid="{53AF0AB8-E1A1-45E7-8E4F-AFE2427633C6}">Suceso</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Uso del proceso</th><td class="sectionTableCell" colspan="2">
<ul>
<li>
<a href="./../../core.base_rup/capabilitypatterns/analysis_design_49725AC4.html" guid="{002674F9-6511-4D15-8623-B761D8C48986}">Análisis y diseño</a>
									&nbsp;&gt;&nbsp;
								<a href="./../../core.base_rup/capabilitypatterns/refine_the_architecture_F40FA195.html" guid="{F2160C54-F666-4736-9982-FC7F58F15FAD}">Perfeccionar la arquitectura</a>
									&nbsp;&gt;&nbsp;
								<a href="./../../core.base_rup/capabilitypatterns/identify_design_elements_6B9768F0.html" guid="_TBDzkEocEdqrjq4i3fchvA">Identificar elementos de diseño</a>
</li>
<li>
<a href="./../../core.base_rup/capabilitypatterns/analysis_design_49725AC4.html" guid="{002674F9-6511-4D15-8623-B761D8C48986}">Análisis y diseño</a>
									&nbsp;&gt;&nbsp;
								<a href="./../../core.base_rup/capabilitypatterns/analyze_behavior_59C89065.html" guid="{DAFB461E-9ADB-4849-8285-B7E3E72BDB43}">Analizar el comportamiento</a>
									&nbsp;&gt;&nbsp;
								<a href="./../../core.base_rup/capabilitypatterns/identify_design_elements_D0EF4513.html" guid="_fNJV8EocEdqrjq4i3fchvA">Identificar elementos de diseño</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Descripci&oacute;n principal</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><p>
    <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Tarea: Análisis de caso de uso</a> da como resultado <b>clases de
    análisis</b>, que representan <b>elementos conceptuales que pueden ejecutar un comportamiento</b>. En diseño, las
    <b>clases de análisis</b> evolucionan hasta convertirse en varios tipos de elementos de diseño:
</p>
<ul>
    <li>
        clases, que representan un conjunto de responsabilidades detalladas;
    </li>
    <li>
        subsistemas, que representan un conjunto de responsabilidades sin detallar, puede que compuesto por otro conjunto
        de subsistemas y, en última instancia, por un conjunto de clases;
    </li>
    <li>
        clases activas, que representan hebras en el sistema;
    </li>
    <li>
        interfaces, que representan declaraciones abstractas de responsabilidades proporcionadas por una clase o
        subsistema.
    </li>
</ul>
<p>
    Asimismo, en diseño también se identifican:
</p>
<ul>
    <li>
        sucesos, que son especificaciones de apariciones interesantes en el tiempo y el espacio que normalmente (si son
        resaltables) requieren alguna respuesta del sistema; y
    </li>
    <li>
        señales, que representan mecanismos asíncronos que se utilizan para comunicar determinados tipos de sucesos dentro
        del sistema.
    </li>
</ul>
<p>
    Estas distinciones más específicas nos permiten examinar distintos aspectos del diseño:
</p>
<ul>
    <li>
        Los sucesos y las señales que se utilizan para comunicarlos nos permiten describir los desencadenantes asíncronos
        de comportamiento a los que debe responder el sistema.
    </li>
    <li>
        Las clases y las subclases nos permiten agrupar responsabilidades relacionadas en unidades que se pueden
        desarrollar con una relativa independencia; las clases cumplen un conjunto atómico de responsabilidades
        relacionadas, mientras que los subsistemas son bloques de construcción compuestos formados a su vez por clases u
        otros subsistemas. Los subsistemas se utilizan para representar los productos de trabajo de un equipo de desarrollo
        como una unidad única e integral de funcionalidad, y como tales se utilizan como unidades de control y gestión de
        configuraciones y como elementos de diseño lógico.
    </li>
    <li>
        Las clases activas se utilizan para representar hebras de control en el sistema, lo que permite el modelado de la
        concurrencia. Las clases activas a menudo se utilizan en composición con otras clases que suelen ser, aunque no
        necesariamente, pasivas: más adelante, este tipo de composición se puede utilizar (de la misma forma que una
        colaboración) para modelar el comportamiento complejo. 
        <p class="reactive">
            En sistemas en tiempo real, se utilizan cápsulas en lugar de clases activas, lo que permite una semántica más
            sólida para simplificar el diseño y aumentar la fiabilidad de las aplicaciones concurrentes. Las cápsulas
            comparten algunos aspectos de las clases y los subsistemas: de hecho, son colaboraciones encapsuladas de clases
            que representan conjuntamente una hebra de control en el sistema. Se diferencian de los subsistemas en el
            sentido de que una cápsula es responsabilidad de un único diseñador, mientras que un subsistema es
            responsabilidad (normalmente) de un equipo de desarrolladores; no obstante, un subsistema puede contener
            cápsulas.&nbsp;
        </p>
    </li>
    <li>
        Las interfaces nos permiten examinar y capturar las 'costuras' del sistema, y definen en términos precisos cómo
        interactuarán las partes constituyentes del sistema.
    </li>
    <li class="reactive">
        En los sistemas en tiempo real, utilizaremos protocolos para definir con precisión los mensajes que se pueden
        enviar y recibir en un puerto de una cápsula.
    </li>
</ul>
<p>
    Al separar y manejar independientemente cada problema representado por estos conceptos, se simplifica el proceso de
    diseño y se clarifica la solución.
</p>
<p>
    Si se debe mantener la rastreabilidad entre los modelos del sistema, se debe documentar durante esta tarea.&nbsp; Para
    obtener más información sobre cómo documentar la rastreabilidad entre el modelo de diseño y otros modelos del sistema,
    consulte <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_model_A82D7B3E.html" guid="2.3158107674855575E-306">Directriz: Modelo de diseño</a>.
</p>
<h4>
    &nbsp;Representación UML 1.x
</h4>
<p>
    De acuerdo con UML 1.5, un subsistema es un tipo especial de paquete que tiene sólo interfaces como elementos públicos.
    Las interfaces proporcionan una capa de encapsulación, lo que permite mantener oculto el diseño interno del subsistema
    de otros elementos de modelo. El subsistema de concepto se utiliza para distinguirlo de los paquetes "ordinarios", que
    son contenedores sin semántica de elementos de modelo; el subsistema representa un determinado uso de paquetes con
    propiedades de tipo clase (de comportamiento).
</p>
<p class="reactive">
    En RUP, las cápsulas se representan utilizando la notación UML 1.5. La mayor parte de esto se puede representar en UML
    2.0 mediante <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/structured_class_FF8DB16F.html" guid="1.1994826813129747E-304">Concepto: Clase estructurada</a>.
</p>
<p class="reactive">
    Consulte <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html" guid="4.792914878943572E-306">Differences Between UML 1.x and UML 2.0</a> para obtener más información.
</p></td>
</tr>
</table>
</div>
<div class="sectionHeading">Pasos</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr>
<td class="sectionTableSingleCell">
<div class="stepHeading"> Identificar sucesos y se&ntilde;ales </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a key="sucesos" text="identificación de" name="XE_events__identification_of" id="XE_events__identification_of" class="index"></a><a id="Identify and Specify Events" name="Identify and Specify Events"></a>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Objetivo</b>
            </td>
            <td width="95%">
                Identificar los sucesos externos e internos, y las señales a las que debe responder el sistema.&nbsp;
            </td>
        </tr>
    </table>
    <p>
        Los sucesos son apariciones externas e internas que provocan acciones en el sistema. Los sucesos y sus
        características permiten dirigir la identificación de elementos de diseño clave como, por ejemplo, las clases
        activas.
    </p>
    <p>
        Del modelo de caso de uso se puede derivar una lista inicial de sucesos externos, a partir de las interacciones de
        los actores con los casos de uso . Los sucesos internos se pueden derivar del texto en los flujos de casos de uso ,
        o se pueden identificar a medida que evoluciona el diseño.
    </p>
    <p>
        Las características más importantes de los sucesos son:
    </p>
    <ul>
        <li>
            interno o externo - ¿El suceso es externo o interno?
        </li>
        <li>
            prioridad - ¿Este suceso debe provocar la suspensión de otros procesos para poder manejarlo?
        </li>
        <li>
            frecuencia - ¿Con qué frecuencia se produce el suceso?
        </li>
        <li>
            distribución de frecuencia - ¿Se produce el suceso a intervalos regulares o hay picos?
        </li>
        <li>
            requisitos de respuesta - ¿Con qué rapidez debe responder el sistema al suceso (distíngase entre la media y el
            peor de los casos)?
        </li>
        <li>
            tipo - ¿Es un suceso de llamada, un suceso de tiempo, un suceso de señal o un suceso de cambio (consulte <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/concepts/events_and_signals_734567DC.html" guid="1.800598287887014E-305">Concepto: Sucesos y señales</a> para ver las definiciones)?
        </li>
    </ul>
    <p>
        Las características de los sucesos se deben capturar según sea necesario para dirigir la identificación de los
        elementos de diseño que los manejan. La captura de características de sucesos tiende a ser más importante en los
        sistemas reactivos (dirigidos por sucesos), pero puede ser útil en otros sistemas como, por ejemplo, aquellos con
        concurrencia y/o mensajería asíncrona.
    </p>
    <p>
        Los sucesos de comunicación asíncrona se pueden modelar como señales para expresar los datos que transportan o para
        expresar relaciones entre señales, por ejemplo, la generalización. En algunos sistemas, en concreto, en los
        sistemas reactivos, es importante relacionar las señales recibidas de dispositivos externos con mecanismos
        específicos como, por ejemplo, interrupciones o mensajes de sondeo específicos.<br />
    </p>
</div></td>
</tr>
</table>
</div>
<div class="stepHeading"> Identificar las clases, las clases activas y los subsistemas </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a id="Identify Classes, Active Classes and Subsystems" name="Identify Classes, Active Classes and Subsystems"></a>
<div align="left">
    <table border="1" width="100%" cellspacing="0" cellpadding="4" style="border: 1px solid rgb(128,128,128)"     bordercolorlight="#808080" bordercolordark="#808080">
        <tr>
            <td width="5%">
                <b>Objetivo</b>
            </td>
            <td width="95%">
                Perfeccionar las <b>clases de análisis</b> en elementos de modelo de diseño adecuados&nbsp;
            </td>
        </tr>
    </table><br />
</div>
<p>
    <b>Identificar clases.</b> Cuando la clase de análisis es simple y representa una única abstracción lógica, se puede
    correlacionar directamente, 1:1, con una <b>clase de diseño</b>. Normalmente, las clases de entidad sobreviven
    relativamente intactas en el diseño. Como las clases de entidad normalmente también son persistentes, determine si la
    clase de diseño debe ser persistente y anótelo según corresponda en la descripción de clase.
</p>
<p>
    Cuando se identifican las clases, se deben agrupar en <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_design_package_8376BC8E.html" guid="{80CC5437-F481-487B-A69B-957D9D236D8D}">Producto
    de trabajo: Paquetes de diseño</a>, a efectos de organización y gestión de configuraciones. Consulte el apartado <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_package_8CF100B8.html" guid="3.3691722315666536E-305">Directriz de producto de trabajo: Paquete de diseño</a> para obtener más información
    sobre cómo tomar decisiones de empaquetado.
</p>
<p>
    <b>Identificar clases activas.</b> Considere los requisitos de concurrencia del sistema en el contexto de los objetos
    de análisis identificados: ¿es necesario que el sistema responda a sucesos generados externamente y, en caso
    afirmativo, qué clases de análisis están 'activas' cuando se producen los sucesos? Los sucesos externos en el modelo de
    caso de uso están representados por estímulos provenientes de los actores, que interactúan con un caso de uso . Observe
    las realizaciones de casos de uso correspondientes para ver qué objetos interactúan cuando se produce un suceso.
    Empiece por agrupar los objetos en conjuntos autónomos de objetos de colaboración; estas agrupaciones representan un
    corte inicial en un grupo que puede formar una clase activa compuesta.
</p>
<p>
    Si los sucesos tienen atributos importantes que se deben capturar, considere modelarlos como clases, una
    &lt;&lt;señal&gt;&gt; estereotipada. En sistemas en tiempo real, estos conjuntos identificados de objetos se deben
    agrupar en cápsulas, que tienen una semántica de encapsulación sólida.
</p>
<p>
    Las instancias de las clases activas representan hebras de ejecución 'lógicas' independientes. Estas hebras de
    ejecución 'lógicas' no se deben confundir ni correlacionar literalmente con hebras de ejecución en el sistema operativo
    (aunque en algún punto se correlacionarán con hebras de ejecución del sistema operativo). Representan hebras de
    ejecución conceptuales independientes en el espacio de soluciones. Nuestro objetivo al identificarlas en este punto del
    diseño es poder particionar la solución en unidades independientes basadas en las 'costuras de concurrencia' naturales
    del sistema. Este tipo de división el trabajo facilita conceptualmente los problemas de tratar con la concurrencia, ya
    que las hebras de ejecución independientes se pueden tratar por separado, excepto en aquellos casos en los que
    comparten clases pasivas subyacentes.
</p>
<p>
    En general, se debe considerar el uso de una clase activa siempre que existan concurrencias y conflictos de
    concurrencia en el dominio del problema. Se debe utilizar una clase activa para representar un objeto concurrente
    externo o una actividad concurrente dentro del sistema. Esto permite supervisar y controlar las actividades
    concurrentes.
</p>
<p>
    Otra opción natural es utilizar clases activas como <b>representaciones internas de dispositivos físicos externos</b>
    que están conectados a un sistema, ya que esas entidades físicas son concurrentes inherentemente. Estas clases de
    "controlador de dispositivo" sirven no sólo para supervisar y controlar los dispositivos físicos correspondientes, sino
    que también aíslan el resto del sistema de las características específicas de los dispositivos. Esto significa que
    puede que no afecte al resto del sistema aunque evolucione la tecnología subyacente en los dispositivos.
</p>
<p>
    Otro lugar común de utilización de las clases activas es para representar actividades concurrentes lógicas. Una
    actividad lógica representa un "objeto" concurrente conceptual como, por ejemplo, una transacción financiera o una
    llamada de teléfono. A pesar de que no se manifiesten directamente como entidades físicas (aunque tienen lugar en el
    mundo físico), a menudo hay razones para tratarlas como tales. Por ejemplo, puede que sea necesario detener
    temporalmente una determinada transacción financiera para evitar un conflicto de concurrencia o puede que sea necesario
    terminarla anormalmente debido a anomalías del sistema. Como estos objetos conceptuales se deben manipular como una
    unidad, se recomienda representarlos como objetos con interfaces propias que proporcionan las capacidades funcionales
    correspondientes.
</p>
<p>
    Un ejemplo concreto de este tipo de objeto conceptual es un <b>controlador de objeto activo</b>. Su objetivo es
    gestionar de forma continua uno o varios objetos activos. Normalmente, esto implica cambiar cada objeto al estado
    operativo deseado; mantenerlo en ese estado ante distintas interrupciones como, por ejemplo, anomalías parciales; y
    sincronizar su operación con la operación de otros objetos. Estos controladores de objetos activos a menudo evolucionan
    a partir objetos de control identificados durante <a class="elementLinkWithUserText" href="./../../core.base_rup/tasks/use_case_analysis_A6990185.html" guid="{28014615-A62F-452D-B821-30C7CAB0EC44}">Tarea: Análisis
    de caso de uso</a> .
</p>
<p>
    Debido a su capacidad de resolver conflictos de concurrencia de forma sencilla y elegante, las clases activas también
    son útiles como <b>guardianes de recursos compartidos</b>. En este caso, uno o más recursos que necesitan varias
    actividades concurrentes se encapsulan dentro de una clase activa. Gracias a la semántica de exclusión mutua
    incorporada, los guardianes protegen estos recursos automáticamente de los conflictos de concurrencia.
</p>
<p>
    <b>En los sistemas en tiempo real, se deben utilizar cápsulas en lugar de clases activas: cuando identifique la
    necesidad de una clase activa de acuerdo con la heurística descrita anteriormente, sustitúyala por una cápsula.</b>
</p>
<p>
    <b>Identificar subsistemas.</b> Cuando la clase de análisis es compleja, por ejemplo, si parece que personifica
    comportamientos que no pueden ser responsabilidad de una única clase que actúe sola, la clase de análisis se debe
    correlacionar con un subsistema de diseño. El subsistema de diseño se utiliza para encapsular las colaboraciones de
    modo que los clientes del subsistema puedan ignorar por completo el diseño interno del subsistema, incluso cuando
    utilicen los servicios que ofrece el subsistema.
</p>
<p>
    Un subsistema está modelado como un componente UML, que tiene sólo interfaces como elementos públicos. Las interfaces
    proporcionan una capa de encapsulación, lo que permite mantener oculto el diseño interno del subsistema de otros
    elementos de modelo. El subsistema de concepto se utiliza para distinguirlo de los paquetes, que son contenedores sin
    semántica de elementos de modelo.
</p>
<p>
    La decisión de crear un subsistema a partir de un conjunto de clases de análisis de colaboración se basa ampliamente en
    si la colaboración la puede desarrollar de forma independiente, actualmente o en el futuro, otro equipo de diseño. Si
    las colaboraciones se pueden contener completamente en un paquete junto con las clases de colaboración, un subsistema
    puede proporcionar un formato de encapsulación más eficaz que el que ofrece un simple paquete. El contenido y las
    colaboraciones de un subsistema se aíslan por completo detrás de una o más interfaces, de modo que el cliente del
    subsistema sólo depende de la interfaz. Así, el diseñador del subsistema está aislado por completo de las dependencias
    externas; el diseñador (o el equipo de diseño) debe especificar el modo en el que se ha realizado la interfaz, pero
    puede cambiar libremente el diseño del subsistema interno sin que afecte a las dependencias externas. En sistemas
    grandes con equipos de gran independencia, este nivel de desacoplamiento combinado con la imposición de la arquitectura
    que ofrecen las interfaces formales constituye un argumento convincente para la elección de subsistemas mejor que
    paquetes simples. Consulte el apartado <a class="elementLinkWithUserText" href="./../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html" guid="1.2314266786534317E-305">Directriz de
    producto de trabajo: Subsistemas de diseño</a> para obtener más información sobre los factores que afectan a la
    elección de utilizar subsistemas como elementos de diseño.
</p></td>
</tr>
</table>
</div>
<div class="stepHeading"> Identificar interfaces de subsistema </div>
<div class="stepContent">
<table cellpadding="0" cellspacing="0" border="0" class="stepTable">
<tr valign="top">
<td><a key="interfaces" text="identificar las de un subsistema" name="XE_interfaces__identifying_a_subsystem's" id="XE_interfaces__identifying_a_subsystem's" class="index"></a><a key="subsistema de diseño" text="identificar interfaces" name="XE_design_subsystem__identifying_interfaces" id="XE_design_subsystem__identifying_interfaces" class="index"></a><a id="Identify Interfaces" name="Identify Interfaces"></a> 
<div align="left">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="100%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <td width="5%">
                    <b>Objetivo</b>
                </td>
                <td width="95%">
                    Identificar los elementos de diseño que formalizan las costuras en el sistema.&nbsp;
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p>
    Las interfaces definen un conjunto de operaciones que realiza algún clasificador. En el modelo de diseño, las
    interfaces se utilizan principalmente para definir las interfaces de los subsistemas. Esto no significa que no se
    puedan utilizar también para las clases, pero para una única clase normalmente es suficiente definir operaciones
    públicas en la clase que, de hecho, definen su 'interfaz'. Las interfaces son importantes para los subsistemas ya que
    permiten la separación de la declaración del comportamiento (la interfaz) de la realización del comportamiento (las
    clases específicas dentro del subsistema que realizan la interfaz). Este desacoplamiento ofrece una forma de aumentar
    la independencia de los equipos de desarrollo que trabajan en las distintas partes del sistema, a la vez que se
    mantienen definiciones precisas de los 'contratos' entre las distintas partes.
</p>
<p>
    <b>Para cada subsistema, identifique un conjunto de interfaces candidatas</b>. Utilizando las colaboraciones agrupadas
    identificadas en el paso anterior, identifique la responsabilidad que se 'activa' cuando se inicia la colaboración. A
    continuación, se perfecciona esta responsabilidad determinando qué información debe proporcionar el 'cliente' y qué
    información se devuelve cuando finaliza la colaboración; estos conjuntos de información se convierten en el valor de
    retorno y los parámetros de entrada y salida de prototipo de la operación que realizará el subsistema. Defina un nombre
    para esta operación, utilizando los convenios de denominación definidos en <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Producto de trabajo: Directrices específicas del proyecto</a>. Repita
    este paso hasta que se hayan definido todas las operaciones que realizará el subsistema.
</p>
<p>
    A continuación, agrupe las operaciones según las responsabilidades relacionadas. Es preferible grupos pequeños a grupos
    grandes, ya que es más probable que exista un conjunto coherente de responsabilidades comunes si hay menos operaciones
    en el grupo. Tenga en cuenta también la reutilización; busque similitudes que faciliten la identificación de la
    funcionalidad reutilizable relacionada. Al mismo tiempo, no invierta demasiado tiempo intentando encontrar la
    agrupación de responsabilidades ideal; recuerde que esta es sólo una agrupación inicial y que en la fase de elaboración
    se realizarán perfeccionamientos iterativos.
</p>
<p>
    <b>Busque similitudes entre las interfaces.</b> Desde el conjunto candidato de interfaces, busque nombres,
    responsabilidades y operaciones que sean similares. Si existen las mismas operaciones en varias interfaces, refactorice
    las interfaces, extrayendo las operaciones comunes a una nueva interfaz. Asegúrese de buscar también en las interfaces
    existentes y reutilizarlas siempre que sea posible. El objetivo es mantener la coherencia de las interfaces y eliminar
    las operaciones redundantes. De esta forma, las interfaces serán más fáciles de entender y evolucionarán mejor con el
    tiempo.
</p>
<p>
    <b>Defina dependencias de interfaces.</b> Los parámetros y el valor de retorno de cada operación de interfaz tendrán
    cada uno un tipo concreto: deben realizar una determinada interfaz o deben ser instancias de un tipo de datos simple.
    En aquellos casos en los que los parámetros son objetos que realizan una determinada interfaz, defina relaciones de
    dependencia entre la interfaz y las interfaces de las que depende. La definición de dependencias entre interfaces
    proporciona información de acoplamiento útil al arquitecto de software, ya que las dependencias de interfaz definen las
    dependencias primarias entre los elementos del modelo de diseño.
</p>
<p>
    <b>Correlacione las interfaces con los subsistemas.</b> Una vez identificadas las interfaces, cree asociaciones de
    <b>realización</b> entre el subsistema y las interfaces que realiza. Una realización del subsistema a una interfaz
    indica que hay uno o varios elementos dentro del subsistema que realizan operaciones de la interfaz. Posteriormente,
    cuando se diseñe el subsistema, estas realizaciones de subsistema-interfaz se perfeccionarán, y el diseñador del
    subsistema especificará qué elementos específicos del subsistema realizan las operaciones de la interfaz. Estas
    realizaciones perfeccionadas sólo son visibles para el diseñador del subsistema; desde el punto de vista del cliente
    del subsistema, sólo está visible la realización del subsistema-interfaz.
</p>
<p>
    <b>Defina el comportamiento especificado por las interfaces.</b> Las interfaces definen a menudo una máquina de estado
    implícita para los elementos que realizan la interfaz. Si las operaciones de la interfaz se deben invocar en un orden
    concreto (por ejemplo, si la conexión de la base datos se debe abrir antes para poder utilizarla), se debe definir una
    máquina de estado que ilustre los estados visibles (o inferidos) públicamente a los que debe dar soporte todo elemento
    de diseño que realiza la interfaz. Esta máquina de estado ayudará al usuario de la interfaz a entender mejor la
    interfaz, y ayudará al diseñador de los elementos que realizan la interfaz a proporcionar el comportamiento correcto
    para su elemento.
</p>
<p>
    <b>Empaquete las interfaces.</b> Las interfaces son propiedad del arquitecto de software; los cambios en las interfaces
    son siempre arquitectónicamente significativos. Para gestionarlas, las interfaces se deben agrupar en uno o varios
    paquetes propiedad del arquitecto de software. Si cada interfaz la realiza un único subsistema, las interfaces se
    pueden colocar en el mismo paquete con el subsistema. Si las interfaces las realizan más de un subsistema, se colocarán
    en un paquete aparte propiedad del arquitecto de software. Esto permite gestionar y controlar las interfaces de forma
    independiente de los subsistemas.
</p>
<h3 class="reactive">
    <a key="protocolo" text="identificación de" name="XE_protocol__identification_of" id="XE_protocol__identification_of" class="index"></a><a id="Identify Capsule Protocols" name="Identify Capsule Protocols">Identificar protocolos de
    cápsula</a>
</h3>
<div align="left">
    <table     style="BORDER-RIGHT: rgb(128,128,128) 1px solid; BORDER-TOP: rgb(128,128,128) 1px solid; BORDER-LEFT: rgb(128,128,128) 1px solid; BORDER-BOTTOM: rgb(128,128,128) 1px solid"      cellspacing="0" bordercolordark="#808080" cellpadding="4" width="100%" bordercolorlight="#808080" border="1">
        <tbody>
            <tr>
                <td width="5%">
                    <p class="reactive">
                        <b>Objetivo</b>
                    </p>
                </td>
                <td width="95%">
                    Identificar los elementos de diseño que formalizan las costuras en el sistema (sólo para el diseño RT).
                </td>
            </tr>
        </tbody>
    </table><br />
</div>
<p class="reactive">
    Los protocolos son parecidos a las interfaces en sistemas dirigidos por sucesos: identifican el 'contrato' entre las
    cápsulas definiendo un conjunto de coincidencia de señales que se utilizan para comunicarse entre hebras de control
    independientes. Mientras que las interfaces se utilizan principalmente para definir la mensajería síncrona utilizando
    un modelo de invocación de llamada de función, los protocolos se utilizan principalmente para definir la comunicación
    asíncrona utilizando una mensajería basada en señales. Los protocolos permiten la separación de la declaración del
    comportamiento (el conjunto de señales) de la realización del comportamiento (los elementos dentro del subsistema que
    realizan la interfaz). Este desacoplamiento ofrece una forma de aumentar la independencia de los equipos de desarrollo
    que trabajan en las distintas partes del sistema, a la vez que se mantienen definiciones precisas de los 'contratos'
    entre las distintas partes.
</p>
<p class="reactive">
    <b>Para cada cápsula, identifique un conjunto de señales de entrada y salida</b>. Utilizando las colaboraciones
    agrupadas identificadas en los pasos anteriores, identifique la responsabilidad que se 'activa' cuando se inicia la
    colaboración. A continuación, se perfecciona esta responsabilidad determinando qué información debe proporcionar el
    'cliente' y qué información se devuelve cuando finaliza la colaboración; estos conjuntos de información se convierten
    en el valor de retorno y los parámetros de entrada de prototipo de una señal que realizará la cápsula a través de uno
    de sus puertos. Defina un nombre para esta señal, utilizando los convenios de denominación definidos en <a class="elementLinkWithUserText" href="./../../core.base_rup/workproducts/rup_project_specific_guidelines_8DC8DA32.html" guid="{E5501201-7EE6-4243-AE91-73880FF76FC1}">Producto de trabajo: Directrices específicas del proyecto</a>. Repita
    este paso hasta que calidadlas señales que realizará la cápsula.
</p>
<p class="reactive">
    A continuación, agrupe las señales según las responsabilidades relacionadas. Es preferible grupos pequeños a grupos
    grandes, ya que es más probable que exista un conjunto coherente de responsabilidades comunes si hay menos señales en
    el grupo. Tenga en cuenta también la reutilización; busque similitudes que faciliten la identificación de la
    funcionalidad reutilizable relacionada. Al mismo tiempo, no invierta demasiado tiempo intentando encontrar la
    agrupación de responsabilidades ideal; recuerde que esta es sólo una agrupación inicial y que en la fase de elaboración
    se realizarán perfeccionamientos iterativos. Proporcione al protocolo un nombre significativo, que describa el rol que
    desempeña el protocolo en las colaboraciones de cápsulas.
</p>
<p class="reactive">
    <b>Busque similitudes entre los protocolos.</b> Desde el conjunto candidato de protocolos, busque nombres,
    responsabilidades y señales que sean similares. Si existen las mismas señales en varios protocolos, refactorice los
    protocolos, extrayendo las señales comunes a una nueva interfaz. Asegúrese de buscar también en los protocolos
    existentes y reutilizarlos siempre que sea posible. El objetivo es mantener la coherencia de los protocolos y eliminar
    las señales redundantes. De esta forma, los protocolos serán más fáciles de entender y evolucionarán mejor con el
    tiempo.
</p>
<p class="reactive">
    <b>Correlacione los protocolos con las cápsulas.</b> Una vez identificados los protocolos, cree <b>puertos</b> en las
    cápsulas que realizan los protocolos. Los puertos de las cápsulas definen sus 'interfaces', el comportamiento que se
    puede solicitar desde la cápsula. Posteriormente, cuando se diseñe la cápsula, la máquina de estado de la cápsula
    describirá el comportamiento especificado por los puertos.
</p>
<p class="reactive">
    <b>Defina el comportamiento especificado por los protocolos.</b> Los protocolos definen a menudo una máquina de estado
    implícita para los elementos que realizan la interfaz. Si las señales de entrada de la interfaz se deben recibir en un
    orden concreto (por ejemplo, si se debe recibir la señal 'sistema-preparado' para que se pueda recibir una determinada
    señal de error), se debe definir una máquina de estado que ilustre los estados visibles (o inferidos) públicamente a
    los que debe dar soporte todo elemento de diseño que realiza el protocolo. Esta máquina de estado ayudará al usuario de
    las cápsulas que realizan el protocolo a entender mejor su comportamiento, y ayudará al diseñador de las cápsulas a
    proporcionar el comportamiento correcto para su elemento.
</p>
<p class="reactive">
    <b>Empaquete los protocolos.</b> Los protocolos son propiedad del arquitecto de software; los cambios en los protocolos
    son siempre arquitectónicamente significativos. Para gestionarlos, los protocolos se deben agrupar en uno o varios
    paquetes propiedad del arquitecto de software. Esto permite gestionar y controlar los protocolos de forma independiente
    de las cápsulas que realizan los protocolos.
</p><br /></td>
</tr>
</table>
</div>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">M&aacute;s informaci&oacute;n</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Listas de comprobaci&oacute;n</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/checklists/capsule_7BF31788.html" guid="1.2115414799051158E-305">Cápsula</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/checklists/protocol_F7AE51B1.html" guid="1.5025405217477615E-306">Protocolo</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Conceptos</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/concepts/events_and_signals_734567DC.html" guid="1.800598287887014E-305">Sucesos y señales</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Directrices</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/guidelines/capsule_7077C999.html" guid="7.026940817483919E-306">Cápsula</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_enterprise_javabeans_ejbs_2581AEE5.html" guid="9.931732120190802E-307">Identificación de Enterprise JavaBeans (EJB)</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_entity_beans_F497D4.html" guid="4.3141371110020564E-306">Identificación de beans de identidad</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_j2ee_application_clients_A6AFA9D0.html" guid="1.2221823675598937E-305">Identificación de clientes de aplicación J2EE</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_java_classes_DAD8355.html" guid="2.5015077375422883E-305">Identificación de clases de Java</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_javabeans_B4489D75.html" guid="2.8184208504373704E-306">Identificación de JavaBeans</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_javaserver_pages_jsps_73396F00.html" guid="1.5318932051119773E-305">Identificación de JSP (JavaServer Pages)</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_message-driven_beans_63C9FE78.html" guid="1.4428031829474456E-305">Identificación de beans controlados por mensajes</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_servlets_951FE427.html" guid="6.749276633239724E-306">Identificación de servlets</a>
</li>
<li>
<a href="./../../tech.j2ee/guidances/guidelines/identifying_session_beans_5E45D5DA.html" guid="6.241144674389355E-307">Identificación de beans de sesión</a>
</li>
</ul>
</td>
</tr>
<tr valign="top">
<th scope="row" class="sectionTableHeading">Instrucciones de la herramienta</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/manage_class_E87F7860.html" guid="{234EB01D-88DF-4EBC-B806-CAA81CD2BF13}">Gestión de clases utilizando Rational Rose</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/reverse_engineer_code_D4050BB0.html" guid="{D674D96E-1A37-48D1-B120-6145C9802E3E}">Ingeniería inversa de código utilizando Rational Rose</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/manage_design_model_1D45D75E.html" guid="{BD1DD906-031C-4D8C-8078-87B6869A8C14}">Gestión del modelo de diseño utilizando Rational Rose</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/manage_subsystems_CE198D48.html" guid="{6943FA40-808B-4E3E-94FE-D7843FA59E91}">Gestión de subsistemas utilizando Rational Rose</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/manage_interfaces_54F93981.html" guid="{C7B694E4-94A5-42F6-9807-E63020E20250}">Gestión de interfaces utilizando Rational Rose</a>
</li>
<li>
<a href="./../../core.base_rup/guidances/toolmentors/identifying_design_elements_F8D68BA1.html" guid="{E6727D13-BE7B-4025-AD39-ECD6FA074D73}">Identificación de elementos de diseño utilizando Rational XDE Developer</a>
</li>
<li>
<a href="./../../tech.rsa/guidances/toolmentors/identifying_design_elements_using_rsa_ext_BF1FC5FE.html" guid="_rYptgK4JEdqFg48R_ivTjA">Identificación de elementos de diseño mediante Rational Software Architect</a>
</li>
<li>
<a href="./../../tech.rsa/guidances/toolmentors/identifying_design_elements_using_rsd_77B519D6.html" guid="_ogso8K4JEdqFg48R_ivTjA">Identificación de elementos de diseño mediante Rational Systems Developer</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Reservados todos los derechos.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
