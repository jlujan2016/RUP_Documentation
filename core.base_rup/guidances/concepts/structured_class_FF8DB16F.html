<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="es" xml:lang="es">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Concepto: Clase estructurada</title>
<meta content="Concept" name="uma.type">
<meta content="structured_class" name="uma.name">
<meta content="Clase estructurada" name="uma.presentationName">
<meta name="element_type" content="concept">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_EOvXUN7HEdm8G6yT7-Wdqw", "_kjFBYN7HEdm8G6yT7-Wdqw", "{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}", "1.1994826813129747E-304"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_mTMIkN7REdmjRZts2c4ZjQ", "{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}", "1.1994826813129747E-304"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_vzRNgDIcEdqDs_9ORT1Rig", "1.1994826813129747E-304"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_QV4x0AISEdqTna4sZVFRow", "_kjFBYN7HEdm8G6yT7-Wdqw", "{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}", "1.1994826813129747E-304"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="1.1994826813129747E-304"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Concepto: Clase estructurada</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/concept.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Una clase estructurada es una clase que consta de partes con una notación &quot;anidada&quot; explícita y se utiliza para modelar jerarquías de contención, que son clase compuestas de &quot;partes&quot;.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relaciones</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Elementos relacionados</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_model_2830034D.html" guid="{8CDAEAD4-5E84-4F50-87FD-3240ED047DE7}">Modelo de diseño</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Descripci&oacute;n principal</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_structured_class__concepts" key="clase estructurada" text="conceptos" name="XE_structured_class__concepts" class="index"></a> 
<h3>
    <a id="Definition" name="Definition"></a>Definición
</h3>
<p>
    Según UML ([<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#UML04" guid="7.755968586980351E-308">UML04</a>]), una clase es un subtipo de clasificador encapsulado y metaclase a la vez, lo
    que proporciona a una clase la capacidad de tener una estructura interna y puertos. UML también define los componentes
    como un subtipo de clase. Por lo tanto, en el contexto de RUP, tanto los <strong>componentes</strong> como las
    <strong>clases</strong> se consideran clases estructuradas.
</p>
<h5>
    <a id="Part" name="Part"></a>Componente
</h5>
<p>
    Una instancia de una clase estructurada contiene un objeto o un conjunto de objetos correspondientes a cada parte.
    Todas estas instancias se destruyen cuando se destruye la instancia de clase estructurada que las contiene.
</p>
<p>
    El ejemplo de abajo muestra dos vistas posibles de la clase Coche:
</p>
<blockquote>
    <p>
        En la figura (a), <strong>Coche</strong> tiene una asociación de composición con el nombre de rol
        <strong>trasera</strong> a una clase <strong>Rueda</strong> y una asociación de composición con el nombre de rol
        <strong>e</strong> a una clase <strong>Motor</strong>. Cualquier instancia de la clase <strong>Motor</strong> se
        puede enlazar con un número arbitrario de instancias de la clase <strong>Rueda</strong>.<br />
        <br />
         En la figura (b), se especifica lo mismo. Sin embargo, en la figura (b) también se especifica que:
    </p>
    <ul>
        <li>
            <p>
                <strong>trasera</strong> y <strong>e</strong> pertenecen a la estructura interna de la clase
                <strong>Coche</strong>. Esto permite especificar los detalles exclusivos de las instancias de las clases
                <strong>Rueda</strong> y <strong>Motor</strong> en el contexto de la clase <strong>Coche</strong>, pero que
                no son aplicables a <strong>ruedas</strong> y <strong>motores</strong> en general.
            </p>
        </li>
        <li>
            <p>
                en el contexto de la clase <strong>Coche</strong>, la instancia que desempeña el rol de <strong>e</strong>
                sólo se puede conectar a dos instancias que desempeñen el rol de <strong>trasero</strong>. Además, las
                instancias que desempeñan los roles <strong>e</strong> y <strong>trasero</strong> sólo se pueden enlazar si
                son roles de la misma instancia de la clase <strong>Coche</strong>.
            </p>
        </li>
        <li style="list-style: none">
            En otras palabras, en las instancias de las clases <strong>Rueda</strong> y <strong>Motor</strong> se aplican
            restricciones adicionales, cuando desempeñan los roles respectivos en una instancia de la clase
            <strong>Coche</strong>. Estas restricciones no son ciertas para instancias de <strong>Rueda</strong> y
            <strong>Motor</strong> en general. Tal como se especifica en la figura (a), se pueden enlazar arbitrariamente
            otras <strong>ruedas</strong> y <strong>motores</strong>.<br />
            <br />
        </li>
    </ul>
</blockquote>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/parts.jpg" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Ejemplo: Componentes que desempeñan su rol en una clase estructurada
</p>
<h5>
    <a id="Connector" name="Connector"></a>Conector
</h5>
<p>
    Un conector es una instancia de relación entre dos componentes de una clase estructurada. Es un enlace que permite la
    comunicación. Los conectores se pueden implementar mediante asociaciones ordinarias o relaciones transitorias, como
    parámetros del procedimiento, variables, valores globales u otros mecanismos.
</p>
<p>
    El "cableado" interno de una clase estructurada se especifica con los conectores de ensamblaje y los conectores de
    delegación:
</p>
<ul>
    <li>
        En la implementación de una clase estructurada, los <strong>conectores de ensamblaje</strong> conectan puertos de
        componentes diferentes. Un mensaje que se envía en un puerto de una clase estructurada se recibe en un puerto
        conectado de otra clase estructurada. Un conjunto de componentes se puede conectar mediante los puertos. No es
        necesario que un componente sepa nada sobre los otros componentes, salvo que existen y cumplen las restricciones de
        los puertos conectados. La comunicación entre las clases estructuradas la modelan sus puertos.
    </li>
    <li style="list-style: none">
        <br />
        <br />
    </li>
    <li>
        Un <strong>conector de delegación</strong> conecta un puerto externo de una clase estructurada con un puerto de uno
        de sus componentes internos. Un mensaje recibido por el puerto externo se pasa al puerto del componente interno; un
        mensaje enviado por el puerto interno se pasa al puerto externo y, después, a la clase estructurada que está
        conectada al puerto externo.
    </li>
</ul>
<h3>
    <a id="Port" name="Port"></a>Puerto
</h3>
<p>
    Un puerto es una característica estructural de una clase estructurada. La encapsulación se puede aumentar forzando las
    comunicaciones desde fuera de la clase estructurada para que pasen a través de los puertos que obedecen a las
    interfaces declaradas, lo que otorga una precisión adicional en la especificación y la interconexión para dicha clase
    estructurada.
</p>
<p>
    Las interfaces necesarias y proporcionadas de un puerto especifican todo lo necesario para las interacciones mediante
    el punto de interacción. Si se alcanzan todas las interacciones de una clase estructurada con su entorno a través de
    los puertos, las cualidades esenciales de la clase estructurada se aíslan totalmente del entorno. Esto permite que una
    clase estructurada de este tipo se utilice en cualquier contexto que cumpla las restricciones que especifican sus
    puertos.
</p>
<p>
    No se presupone nada sobre el modo de implementación de un puerto. Se puede implementar como un objeto explícito o
    puede ser simplemente un concepto virtual que no aparece explícitamente en la implementación.
</p>
<p>
    A continuación, se proporcionan ejemplos de puertos:
</p>
<h5>
    Ejemplo 1
</h5>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/ports.jpg" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Puerto de un motor que se utiliza en un coche y en un barco
</p>
<p>
    La figura de arriba muestra una clase <strong>Motor</strong> con un puerto <strong>p</strong> y dos interfaces:
</p>
<ul>
    <li>
        Una interfaz proporcionada <strong>tren transmisor de potencia</strong>, que especifica los servicios que ofrece el
        motor en este puerto (es decir, las operaciones y las recepciones a las que se pueden acceder mediante la
        comunicación que llega a este puerto).
    </li>
    <li>
        Una interfaz necesaria <strong>alimentación</strong>, que especifica los servicios que el motor espera que
        proporcione el entorno.
    </li>
</ul>
<p>
    En el puerto <strong>p</strong>, la clase <strong>Motor</strong> está totalmente encapsulada; se puede especificar sin
    ningún conocimiento del entorno en que se integrará el motor. Mientras el entorno obedezca las restricciones que
    expresan las interfaces proporcionadas y necesarias del motor, el motor funcionará correctamente.<br />
    <br />
     Para ilustrarlo, en este ejemplo se muestran dos usos de la clase <strong>Motor</strong>:
</p>
<ul>
    <li>
        La clase <strong>Coche</strong> conecta el puerto <strong>p</strong> del motor a un conjunto de ruedas mediante el
        <strong>eje</strong>.
    </li>
    <li>
        La clase <strong>Barco</strong> conecta el puerto <strong>p</strong> del motor con una hélice mediante el
        <strong>eje</strong>.
    </li>
</ul>
<p>
    Mientras la interacción entre el <strong>Motor</strong> y el componente enlazado con su puerto <strong>p</strong>
    cumpla las restricciones que especifican las interfaces necesarias y proporcionadas, el motor funcionará tal como se
    especifica, independientemente de si se trata del motor de un coche o del motor de un barco.
</p>
<p>
    Además, aunque el <strong>Motor</strong> tuviese otros puertos declarados, como un puerto <strong>f</strong> para el
    <strong>Consumo de combustible</strong>, las ruedas de un coche y la hélice de un barco seguirían accediendo al
    <strong>Motor</strong> a través del puerto <strong>p</strong>. El puerto <strong>f</strong> sería interesante para un
    medidor de combustible, independientemente de la clase de combustible que se utilizase y la clase de medidor de
    combustible que puedan tener los coches y los barcos.
</p>
<h5>
    Ejemplo 2
</h5>
<p>
    Este ejemplo de puertos se basa en la API de registro con Java ([<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#JAV03" guid="7.755968586980351E-308">JAV03</a>]), que es
    un paquete que proporciona las siguientes clases e interfaces de los recursos centrales de registro de la plataforma
    Java 2, entre otras:
</p>
<ul>
    <li style="list-style: none">
        <strong>Registrador</strong> es la entidad principal donde las aplicaciones hacen llamadas de registro. Se utiliza
        para registrar mensajes para un componente de la aplicación o del sistema específico
    </li>
    <li style="list-style: none">
        <strong>Nivel</strong> proporciona un baremo de la importancia y la urgencia de un mensaje de registro
    </li>
    <li style="list-style: none">
        <strong>Filtro</strong> proporciona un control exhaustivo de lo que se registra, además del control que
        proporcionan los niveles de registro
    </li>
    <li style="list-style: none">
        <strong>Manejador</strong> coge los mensajes del registrador y los exporta a diferentes destinos (memoria,
        corrientes de salida, consolas, archivos y sockets)
    </li>
    <li style="list-style: none">
        <strong>Formateador</strong> proporciona soporte para formatear los registros
    </li>
</ul>
<p>
    Estas clases e interfaces están involucradas en dos tipos importantes de colaboraciones. Algunas clases e interfaces se
    utilizan para escribir en el registro y otras se utilizan para administrarlo. La figura de abajo muestra dos
    colaboraciones diferentes que los clientes y los administradores tienen con el registro, modeladas como colaboraciones
    UML:
</p>
<ul>
    <li style="list-style: none">
        Colaboración de <strong>escritura</strong>, donde el rol <strong>ClienteRegistro</strong> se conecta con el rol
        <strong>EscritorRegistro</strong> para escribir en el registro.
    </li>
    <li style="list-style: none">
        Colaboración de <strong>administración</strong>, donde el rol <strong>AdministradorRegistro</strong> se conecta con
        el rol <strong>ControladorRegistro</strong> para acceder al registro y cambiar su configuración.<br />
    </li>
</ul>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/collab.gif" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Diferentes colaboraciones que tienen los clientes y los administradores con el registro
</p>
<p>
    Una posible representación UML 2.0 para modelar los servicios de registro y sus colaboraciones sería utilizar un
    componente con puertos e interfaces declaradas, como se muestra en la figura de abajo:
</p>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/ports1.gif" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Paquete de la API de registro con Java que se está implementando como un componente con las interfaces proporcionadas
    agrupadas en puertos
</p>
<p>
    En la especificación API de registro con Java, algunos de los servicios de registro se implementaron como clases y
    otros como interfaces. En este ejemplo, modelamos estos servicios como interfaces proporcionadas, que se podrían
    realizar por partes en el componente. Las dos clases diferentes de comportamiento relacionadas con las colaboraciones
    de <strong>escritura</strong> y <strong>administración</strong> que se mencionan más arriba podrían representarse
    mediante interfaces agrupadas lógicamente en puertos. Por lo tanto, tenemos:
</p>
<ul>
    <li style="list-style: none">
        Interfaces de <strong>registrador</strong> y <strong>nivel</strong> agrupadas en el puerto
        <strong>EscritorRegistro</strong>. Los clientes de registro acceden a estas interfaces para escribir en el
        registro<strong>.</strong>
    </li>
    <li style="list-style: none">
        Interfaces de <strong>manejador</strong>, <strong>filtro</strong> y <strong>formateador</strong> agrupadas en el
        puerto <strong>ControladorRegistro</strong>. Los administradores de registro acceden a estas interfaces para tener
        acceso a la configuración del registro de cambios y al registro.
    </li>
</ul>
<p>
    Esta alternativa de modelado supone una separación de asuntos, ya que agrupa lógicamente las interfaces en puertos
    diferentes. Esto nos proporciona una precisión adicional para la especificación del componente y la interconexión que
    pueda tener con el mundo externo.
</p>
<h3>
    <a id="Modeling" name="Modeling"></a>Modelado
</h3>
<p>
    Durante el diseño, las clases y los componentes se pueden descomponer en recopilaciones de componentes conectados que,
    a su vez, se pueden a descomponer.
</p>
<p>
    Un <strong>diagrama de estructura compuesta</strong> se puede utilizar para mostrar la descomposición de una clase
    estructurada. A modo de ejemplo, la figura de abajo muestra un diagrama de estructura compuesta para la taquilla del
    sistema de entradas. Esta clase se descompone en tres partes:
</p>
<ul>
    <li>
        Una interfaz de vendedor de entradas
    </li>
    <li>
        Una guía de rendimiento que recupera realizaciones en función de la fecha y otros criterios
    </li>
    <li>
        Un conjunto de bases de datos que contienen los datos de las realizaciones y las entradas.
    </li>
</ul>
<p>
    Cada parte interactúa mediante una interfaz bien definida que especifican los puertos. La taquilla entera interactúa
    con el exterior a través de un puerto. Los mensajes de este puerto se envían a la clase de vendedor de entradas, pero
    la estructura interna de la clase de taquilla se oculta de los clientes externo.
</p>
<p align="center">
    <img src="./../../../core.base_rup/guidances/concepts/resources/structclass.gif" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Ejemplo: Diagrama de estructura compuesta para un sistema de entradas.
</p>
<h3>
    <a id="UML 1.x Representation" name="UML 1.x Representation"></a>Representación UML 1.x
</h3>
<p>
    Tenga en cuenta que una clase estructurada es un concepto nuevo en UML 2.0.
</p>Gran parte de lo que RUP define como Cápsula se puede representar utilizando una clase estructurada como notación
(consulte los apartados <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Producto de trabajo: Cápsula</a> y <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/capsule_7077C999.html" guid="7.026940817483919E-306">Directriz de producto de
trabajo: Cápsula</a> para obtener más información sobre este tema). 
<p>
    Si su herramienta sólo soporta UML 1.5, en los apartados <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_capsule_FC4A34FD.html" guid="{4423FCE1-FF59-4C8E-A6C4-AA4B13CB3250}">Producto de
    trabajo: Cápsula</a> y <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/capsule_7077C999.html" guid="7.026940817483919E-306">Directriz de producto de
    trabajo: Cápsula</a> se describe una representación alternativa.
</p>
<p>
    Consulte <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/supportingmaterials/differences_between_uml_1_x_and_uml_2_0_CA70F2E6.html" guid="4.792914878943572E-306">Diferencias entre UML 1.x y UML 2.0</a> para obtener más información.<br />
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Reservados todos los derechos.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
