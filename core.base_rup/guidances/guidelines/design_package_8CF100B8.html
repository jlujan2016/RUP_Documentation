<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="es" xml:lang="es">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directriz: Paquete de dise&ntilde;o</title>
<meta content="Guideline" name="uma.type">
<meta content="design_package" name="uma.name">
<meta content="Paquete de dise&ntilde;o" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_f6_YwN7DEdmsEI4YDGX2ag", "_qwxC8N7YEdmjRZts2c4ZjQ", "{DB21F5EF-810B-4994-B120-79FA8774FA9D}", "3.3691722315666536E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_f6_YwN7DEdmsEI4YDGX2ag", "_qwxC8N7YEdmjRZts2c4ZjQ", "{86253FE7-0036-4D14-8BD7-C18CE86A5E14}", "3.3691722315666536E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_n7ZcgN7REdmjRZts2c4ZjQ", "{80CC5437-F481-487B-A69B-957D9D236D8D}", "3.3691722315666536E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "3.3691722315666536E-305"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_qwxC8N7YEdmjRZts2c4ZjQ", "{DB21F5EF-810B-4994-B120-79FA8774FA9D}", "3.3691722315666536E-305"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_zRigkAILEdq-_NKqZM1EhA", "_qwxC8N7YEdmjRZts2c4ZjQ", "{86253FE7-0036-4D14-8BD7-C18CE86A5E14}", "3.3691722315666536E-305"]}, {view: "view:_OAq98E7KEduvcvbnLvkXhA", path: ["_OAq98E7KEduvcvbnLvkXhA", "_pTvboE7MEduvcvbnLvkXhA", "{DB21F5EF-810B-4994-B120-79FA8774FA9D}", "3.3691722315666536E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="3.3691722315666536E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Directriz: Paquete de dise&ntilde;o</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Un paquete de diseño es una construcción que se utiliza para partir el modelo de diseño. En esta directriz se explica cómo identificar y especificar paquetes de diseño.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relaciones</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Elementos relacionados</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/workproducts/rup_design_package_8376BC8E.html" guid="{80CC5437-F481-487B-A69B-957D9D236D8D}">Paquete de diseño</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_designer_BA8DE74E.html" guid="{DB21F5EF-810B-4994-B120-79FA8774FA9D}">Diseñador</a>
</li>
<li>
<a href="./../../../core.base_rup/roles/rup_capsule_designer_F3E66EDF.html" guid="{86253FE7-0036-4D14-8BD7-C18CE86A5E14}">Diseñador de cápsulas</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Descripci&oacute;n principal</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_design_package__guidelines_for" key="paquete de diseños" text="directrices para" name="XE_design_package__guidelines_for" class="index"></a> 
<h3>
    <a id="Introduction" name="Introduction">Introducción</a>
</h3>
<p>
    <a key="subsistema de diseño" text="paquetes frente a subsistemas" name="XE_design_subsystem__packages_vs._subsystems" id="XE_design_subsystem__packages_vs._subsystems" class="index"></a><a key="paquete de diseños" text="subsistemas frente a paquetes" name="XE_design_package__subsystems_vs._packages" id="XE_design_package__subsystems_vs._packages" class="index"></a>El modelo de diseño se puede estructurar en unidades
    más pequeñas para facilitar la comprensión. Agrupando los elementos de modelo de diseño en paquetes y subsistemas y
    mostrando, a continuación, como se relacionan estas agrupaciones entre si, es más fácil de comprender la estructura
    global del modelo. Tenga en cuenta que un <b><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/design_subsystem_AB08ECC8.html" guid="_yGBMgNnmEdmO6L4XMImrsA">subsistema de diseño</a></b> se modela como un componente que realiza una o más
    interfaces; para obtener más información, consulte el apartado <a class="elementLinkWithUserText" href="./../../../core.base_rup/workproducts/rup_design_subsystem_1A8D169B.html" guid="{A3C60B25-9780-4BFA-81AF-C1AD40D8A833}">Producto de trabajo: Subsistema de diseño</a> y <a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/guidelines/design_subsystem_B26FD609.html" guid="1.2314266786534317E-305">Directriz de producto de trabajo: Subsistema de diseño</a>. Los paquetes de diseños, por
    otra parte, son sólo para agrupar.
</p>
<h3>
    <a key="visibilidad" text="de contenido en el paquete" name="XE_visibility__of_content_in_package" id="XE_visibility__of_content_in_package" class="index"></a><a key="paquete de diseños" text="describir cómo dependen los paquetes entre sí" name="XE_design_package__describing_how_packages_depend_on_each_other" id="XE_design_package__describing_how_packages_depend_on_each_other" class="index"></a><a id="Package Content Visibility" name="Package Content Visibility">Visibilidad del contenido del paquete</a>
</h3>
<p>
    Una clase contenida en un paquete puede ser pública o privada. Una <a key="clase pública" text="en paquete" name="XE_public_class__in_package" id="XE_public_class__in_package" class="index"></a><b>clase pública</b> se puede
    asociar a otra clase. Una <a key="clase privada" text="en paquete" name="XE_private_class__in_package" id="XE_private_class__in_package" class="index"></a><b>clase privada</b> se puede asociar sólo a clases contenidas en
    el paquete.
</p>
<p>
    Una interfaz de paquete consta sólo de las clases públicas del paquete. La interfaz del paquete (clases públicas)
    aíslan e implementan las dependencias de otros paquetes. De este modo, el desarrollo paralelo se simplifica porque
    puede establecer las interfaces antes, y los desarrolladores necesitarán conocer sólo los cambios de las interfaces de
    otros paquetes.
</p>
<h3>
    <a key="paquete de diseños" text="criterios de partición de paquetes" name="XE_design_package__package_partitioning_criteria" id="XE_design_package__package_partitioning_criteria" class="index"></a><a id="Package-Partitioning Criteria" name="Package-Partitioning Criteria">Criterios de partición de
    paquetes</a>
</h3>
<p>
    Puede partir el modelo de diseño por una serie de motivos:
</p>
<ul>
    <li>
        Puede utilizar los paquetes y subsistemas como orden, configuración, o unidades de entrega cuando un sistema ha
        finalizado.
    </li>
    <li>
        La asignación de recursos y la competencia de diferentes equipos de desarrollo puede requerir que el proyecto se
        divida entre diferentes grupos en diferentes sitios. Los subsistemas, con interfaces definidas, proporcionan un
        modo de dividir el trabajo entre equipos de forma controlada y coordinada, permitiendo que el diseño y la
        implementación se desarrollen en paralelo.
    </li>
    <li>
        Los subsistemas se pueden utilizar para estructurar el modelo de diseño de modo que refleje los tipos de usuario.
        Muchos requisitos de cambio se originan en los usuarios; los subsistemas garantizan que estos cambios de un tipo de
        usuario concreto afectarán sólo a los componentes del sistema que corresponden a ese tipo de usuario.
    </li>
    <li>
        En algunas aplicaciones, cierta información debe estar accesible sólo para unas cuantas personas. Los subsistemas
        le permiten mantener la privacidad en áreas donde es necesario.
    </li>
    <li>
        Si está construyendo un sistema de soporte, puede, mediante subsistemas y paquetes para darle una estructura
        similar a la estructura del sistema que se soporta. De este modo, puede sincronizar el mantenimiento de dos
        sistemas.
    </li>
    <li>
        <a key="producto existente" text="representar con paquetes" name="XE_existing_product__representing_with_packages" id="XE_existing_product__representing_with_packages" class="index"></a>Los subsistemas se utilizan para representar
        los productos existentes y los servicios que utiliza el sistema (por ejemplo, productos COTS, y bibliotecas), tal
        como se explica en las secciones siguientes.
    </li>
</ul>
<h4>
    <a key="clase de límite" text="empaquetar" name="XE_boundary_class__packaging" id="XE_boundary_class__packaging" class="index"></a><a id="Packaging Boundary Classes" name="Packaging Boundary Classes">Clase de límite de paquete</a>
</h4>
<p>
    Cuando se distribuyen las clases de límite a paquetes, existen dos estrategias diferentes que se pueden aplicar; cuál
    escoger depende de si las interfaces del sistema pueden cambiar mucho en el futuro o no.
</p>
<ul>
    <li>
        Si es probable que la interfaz del sistema se reemplace, o que sufra cambios considerables, la interfaz debe
        separarse del resto del modelo de diseño. Cuando la interfaz de usuario se haya cambiado, sólo afectará a estos
        paquetes. Un ejemplo de cambio importante es la conmutación de una interfaz orientada a la línea a una interfaz
        orientada a ventana.
    </li>
</ul>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp2.gif" width="234" height="148" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Si el objetivo principal es simplificar los cambios de interfaz más importantes, las clases de límite se colocarán en
    uno (o varios) paquetes separados.
</p>
<ul>
    <li>
        Si no se han planificado cambios importantes en la interfaz, los cambios de los servicios del sistema deben ser el
        principio de orientación, en lugar de los cambios de la interfaz. Las clases de límite se colocarán entonces todas
        juntas con las clases de entidad y control con las que están funcionalmente relacionadas. De este modo, será fácil
        ver qué clases de límite están afectadas si se cambia una cierta clase de entidad o de control.
    </li>
</ul>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp3.gif" width="257" height="71" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Para simplificar los cambios a los servicios del sistema, las clases de límite se empaquetan con las clases con las que
    están funcionalmente relacionadas.
</p>
<p>
    Las clases de límite obligatorias que no están funcionalmente relacionadas con cualquier entidad- o clases de control,
    se deben colocar en paquetes separados, junto con las clases de límite que pertenecen a la misma interfaz.
</p>
<p>
    Si una clase de límite está relacionada con un servicio opcional, agrúpela con las clases que colaboran para
    proporcionar el servicio, en un subsistema separado. El subsistema se correlacionará con un componente opcional que se
    proporcionará cuando se solicite la funcionalidad opcional.
</p>
<h4>
    <a key="paquete de diseños" text="clases relacionadas por la función, buscar paquetes para" name="XE_design_package__functionally_related_classes?_finding_packages_for" id="XE_design_package__functionally_related_classes?_finding_packages_for" class="index"></a><a id="Packaging Functionally Related Classes" name="Packaging Functionally Related Classes">Clases relacionadas con la
    funcionalidad de paquete</a>
</h4>
<p>
    Un paquete debe identificarse para cada grupo de clases que estén funcionalmente relacionadas. Existen varios criterios
    prácticos que se pueden aplicar al juzgar si dos clases están funcionalmente relacionadas. Son, en orden de importancia
    decreciente:
</p>
<ul>
    <li>
        Si los cambios en el comportamiento y/o estructura de una clase requieren cambios en otra clase, las dos clases
        están funcionalmente relacionadas.
    </li>
</ul>
<blockquote>
    <p class="exampleheading">
        Ejemplo
    </p>
    <p class="example">
        Si se añade un nuevo atributo a la clase de entidad <b>Pedido</b>, es muy probable que requiera la actualización de
        la clase de control <b>Administrador de pedidos</b>. Por lo tanto, pertenecen al mismo paquete, <b>Gestión de
        pedidos</b>.
    </p>
</blockquote>
<ul>
    <li>
        Es posible descubrir si una clase está funcionalmente relacionada con otra empezando por una clase - por ejemplo,
        una clase de entidad - y examinando el impacto de eliminarla del sistema. Las clases que sean superfluas como
        resultado de la eliminación de una clase están conectadas de algún modo con la clase eliminada. Por superfluas,
        queremos decir que la clase sólo la utiliza la clase eliminada, o que depende de la clase eliminada.
    </li>
</ul>
<blockquote>
    <p class="exampleheading">
        Ejemplo
    </p>
    <p class="example">
        Existe un paquete <b>Gestión de pedidos</b> que contiene dos clases de control <b>Administrador de pedidos</b> y
        <b>Registrador de pedidos</b>, en el <b>Sistema de gestión de almacén</b>. Las dos clases de control modelan
        servicios respecto a la gestión de pedidos en el depósito. Todos los atributos de pedido y las relaciones se
        almacenan por la clase de entidad <b>Pedido</b>, que sólo existe para la gestión de pedidos. Si se elimina la clase
        de entidad, no habrá necesidad de <b>Administrador de pedidos</b> o <b>Registrador de pedidos</b>, porque sólo son
        útiles si el <b>Pedido</b> existe. Por lo tanto, la clase de entidad <b>Pedido</b> deberá incluirse en el mismo
        paquete que las dos clases de control.
    </p>
</blockquote>
<p class="picturecenter" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp4.gif" width="393" height="163" alt="Diagrama descrito en el texto adjunto." />
</p>
<blockquote>
    <p class="picturetext" align="center">
        <b>Administrador de pedidos</b> y <b>Registrador de pedidos</b> pertenecen al mismo paquete que <b>Pedido</b>,
        porque resultan superfluos si se elimina <b>Pedido</b> del sistema.
    </p>
</blockquote>
<ul>
    <li>
        Dos objetos pueden estar funcionalmente relacionados si interactúan con un gran número de mensajes, o si tienen una
        intercomunicación complicada.
    </li>
</ul>
<blockquote>
    <p class="example">
        <b>Ejemplo</b>
    </p>
    <p class="example">
        La clase de control <b>Realizador de tareas</b> envía y recibe muchos mensajes desde y hacia la <b>Interfaz del
        transportador</b> Esta es otra indicación que se debe incluir en el mismo paquete, <b>Gestión de tareas</b>.
    </p>
</blockquote>
<ul>
    <li>
        Una clase de límite puede estar funcionalmente relacionada con una clase de entidad concreta si la función de la
        clase de límite es presentar la clase de entidad.
    </li>
</ul>
<blockquote>
    <p class="example">
        <b>Ejemplo</b>
    </p>
    <p class="example">
        La clase de límite <b>Formulario de palet</b>, en el <b>Sistema de gestión de almacén</b>, presenta una instancia
        de la clase de entidad <b>Palet</b> al usuario. Cada <b>Palet</b> se representa con un número de identificación en
        la pantalla. Si la información sobre un <b>Palet</b> se cambia, por ejemplo, si el <b>Palet</b> también tiene un
        nombre, la clase de límite puede tener que cambiarse también. El <b>Formulario de palet</b> deberá incluirse en el
        mismo paquete que <b>Palet</b>.
    </p>
</blockquote>
<ul>
    <li>
        Dos clases pueden estar funcionalmente relacionadas si interactúan con, o están afectadas por, el mismo actor. Si
        dos clases no implican al mismo actor, no deben encontrarse en el mismo paquete. La última norma se puede omitir
        por motivos más importantes.
    </li>
</ul>
<blockquote>
    <p class="example">
        <b>Ejemplo</b>
    </p>
    <p class="example">
        Hay un paquete <b>Gestión de tareas</b> en el <b>Sistema de gestión de almacén</b>, que incluye, entre otras, la
        clase de control <b>Realizador de tareas</b>. Este es el único paquete implicado con el actor <b>Transportador</b>,
        el transportador físico que puede transportar un palet en el almacén. El actor interactúa con la clase de control
        <b>Realizador de tareas</b> a través de la clase de límite <b>Interfaz de transportador</b>. Esta clase de límite
        deberá incluirse en el paquete <b>Gestión de tareas</b>.
    </p>
    <p class="example" align="center">
        <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp5.gif" width="470" height="163" alt="Diagrama descrito en el texto adjunto." />
    </p>
    <p class="picturetext">
        <b>Interfaz de transportador</b> y <b>Realizador de tareas</b> pertenecen al mismo paquete ya que ambos están
        afectados por los cambios del actor <b>Transportador</b>.
    </p>
</blockquote>
<ul>
    <li>
        Dos clases pueden estar funcionalmente relacionadas si existen relaciones entre ellas (asociaciones, agregaciones,
        etc.). Por supuesto, este criterio no se puede seguir descuidadamente, sino que se puede utilizar cuando no sea
        aplicable ningún otro criterio.
    </li>
    <li>
        Una clase puede estar funcionalmente relacionada con la clase que crea instancias de esta.
    </li>
</ul>
<p>
    Estos dos criterios determinan cuando dos clases <b>no</b> deben colocarse en el mismo paquete:
</p>
<ul>
    <li>
        Dos clases que estén relacionadas con actores diferentes no deben colocarse en el mismo paquete.
    </li>
    <li>
        Una clase opcional y una clase obligatoria no deben colocarse en el mismo paquete.
    </li>
</ul>
<h3>
    <a id="Evaluating Package Cohesion" name="Evaluating Package Cohesion">Cohesión del paquete de evaluación</a>
</h3>
<p>
    Primero, todos los elementos de un paquete deben tener la misma condición de opcional: no puede haber elementos de
    modelo opcionales en un paquete obligatorio.
</p>
<p class="exampleheading">
    Ejemplo
</p>
<p class="example">
    La clase de entidad obligatoria <b>Tipo de artículo</b> tiene, entre otros, un atributo denominado <b>Reabastecer el
    umbral</b>. La función de reabastecer, sin embargo, es opcional en el sistema. Por lo tanto, <b>Artículo</b> debe
    dividirse en dos clases de entidad, donde la clase opcional se relaciona con la clase obligatoria.
</p>
<p>
    Un paquete que se considere obligatorio no puede depender de ningún paquete que se considere opcional.
</p>
<p>
    Por norma, dos actores diferentes no pueden utilizar un único paquete. El motivo para esto es que un cambio en el
    comportamiento de un actor no debería afectar también a otros actores. Existen excepciones a esta regla, como para los
    paquetes que constituyen servicios opcionales. Los paquetes de este tipo no deben dividirse, independientemente de
    cuantos actores lo utilicen. Por lo tanto, divida cualquier paquete, o clase, que utilizan varios paquetes, a menos que
    el paquete sea opcional.
</p>
<p>
    Todas las clases del mismo paquete deben estar funcionalmente relacionadas. Si ha seguido los criterios de la sección
    "Encontrar paquetes de clases funcionalmente relacionadas", las clases de un paquete estarán funcionalmente
    relacionadas entre si. Sin embargo, una clase particular puede contener por si misma "demasiado" comportamiento, o
    relaciones que no pertenecen a la clase. Parte de la clase debería eliminarse para convertirla en una clase totalmente
    nueva, o en cualquier otra clase, que probablemente pertenecerá a otro paquete.
</p>
<p class="exampleheading">
    Ejemplo
</p>
<p class="example">
    El comportamiento de una clase de control <b>A</b>, en un paquete no debe depender demasiado de una clase, <b>B</b>, en
    otro paquete. Para aislar el comportamiento específico <b>B</b>, la clase de control <b>A</b> debe dividirse en dos
    clases de control, <b>A'</b> y <b>A"</b>. El comportamiento específico <b>B</b> se coloca en la nueva clase de control,
    <b>A"</b>, que se coloca en el mismo paquete que <b>B</b>. La nueva clase <b>A"</b> también obtiene una relación, como
    generalización, con el objeto original <b>A'</b>.
</p>
<p class="example" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp6.gif" width="316" height="206" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    Para aislar el comportamiento específico <b>B</b>, la clase de control <b>A</b>, a la que falta homogeneidad, se divide
    en dos clases de control, <b>A'</b> y <b>A'</b>.
</p>
<h3>
    <a id="Describing Packages Dependendencies" name="Describing Packages Dependendencies">Descripción de las dependencias
    del paquete</a>
</h3>
<p>
    Si una clase en un paquete tiene una asociación con una clase en un paquete diferente, estos paquetes dependen del
    otro. Las dependencias de los paquetes se modelan mediante la relación de dependencia entre los paquetes. Las
    relaciones de dependencia nos ayudan a valorar las consecuencias de los cambios: un paquete del que dependen muchos
    paquetes es más difícil de cambiar que uno del que no depende ningún paquete.
</p>
<p>
    Como se descubrirán varias dependencias como esta durante la especificación de los paquetes, estas relaciones pueden
    cambiar durante el trabajo. La descripción de una relación de dependencia puede incluir información sobre qué
    relaciones de clase han causado la dependencia. Como esto introduce información que es difícil de mantener, debe
    llevarse a cabo sólo si la información es pertinente y de valor.
</p>
<p class="exampleheading">
    Ejemplo
</p>
<p class="example">
    En el <b>Sistema de gestión de almacén</b>, existe la relación de dependencia del paquete <b>Gestión de pedidos</b> al
    paquete <b>Gestión de elementos</b>. Esta asociación surge porque la clase de entidad <b>Pedido</b> de <b>Gestión de
    pedido</b> tiene una asociación con la clase de entidad <b>Tipo de elemento</b> en el paquete de pedido.
</p>
<p class="example" align="center">
    <img src="./../../../core.base_rup/guidances/guidelines/resources/md_desp7.gif" width="264" height="256" alt="Diagrama descrito en el texto adjunto." />
</p>
<p class="picturetext">
    El paquete <b>Gestión de pedido</b> depende de <b>Gestión de elemento</b>, porque existe una asociación entre dos
    clases de los paquetes.
</p>
<h3>
    <a id="Evaluating Package Coupling" name="Evaluating Package Coupling">Acoplamiento del paquete de evaluación</a>
</h3>
<p>
    El acoplamiento de paquetes es positivo y negativo: positivo, porque el acoplamiento representa la reutilización, y
    negativo, porque el acoplamiento representa las dependencias que dificultan el cambio y la evolución del sistema. Se
    pueden seguir algunos principios generales:
</p>
<ul>
    <li>
        Los paquetes no se deben acoplar de forma cruzada (es decir, no deben ser codependientes); por ejemplo, dos
        paquetes no deberían depender el uno del otro.
    </li>
</ul>
<blockquote>
    <p align="center">
        <img src="./../../../core.base_rup/guidances/guidelines/resources/md_dpkg1.gif" width="300" height="109" alt="Diagrama descrito en el texto adjunto." />
    </p>
    <p class="picturetext">
        En estos casos, los paquetes deben reorganizarse para eliminar las dependencias cruzadas.
    </p>
</blockquote>
<ul>
    <li>
        Los paquetes de las capas inferiores no deberían depender de los paquetes de las capas superiores. Los paquetes
        sólo deberían depender de los paquetes de la misma capa y de la capa inferior siguiente.
    </li>
</ul>
<blockquote>
    <p align="center">
        <img src="./../../../core.base_rup/guidances/guidelines/resources/md_dpkg2.gif" width="200" height="239" alt="Diagrama descrito en el texto adjunto." />
    </p>
    <p class="picturetext">
        En estos casos, la funcionalidad debe repartirse. Una solución es indicar las dependencias en términos de
        interfaces, y organizar las interfaces de la capa inferior.
    </p>
</blockquote>
<ul>
    <li>
        En general, las dependencias no deberían omitir las capas, a menos que el comportamiento dependiente sea común a
        través de todas las capas, y la alternativa es simplificar el paso a través de las invocaciones de operación a
        través de las capas.
    </li>
    <li>
        Los paquetes no deben depender de los subsistemas, sólo de otros paquetes o de interfaces.
    </li>
</ul><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Reservados todos los derechos.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
