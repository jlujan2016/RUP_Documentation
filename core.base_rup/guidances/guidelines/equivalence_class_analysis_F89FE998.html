<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" lang="es" xml:lang="es">
<head>
<META http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>Directriz: An&aacute;lisis de clase de equivalencia</title>
<meta content="Guideline" name="uma.type">
<meta content="equivalence_class_analysis" name="uma.name">
<meta content="An&aacute;lisis de clase de equivalencia" name="uma.presentationName">
<meta name="element_type" content="other">
<meta content="description" name="filetype">
<meta name="role" content="">
<link type="text/css" href="./../../../css/default.css" rel="StyleSheet">
<script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageResource.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageSubSection.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/ContentPageToolbar.js"></script><script language="JavaScript" type="text/javascript" src="./../../../scripts/contentPage.js"></script><script language="JavaScript" type="text/javascript">
					var backPath = './../../../';
					var imgPath = './../../../images/';
					var nodeInfo=[{view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_EOvXUN7HEdm8G6yT7-Wdqw", "_SPvXcN7IEdm8G6yT7-Wdqw", "{D525758B-EBA2-4F59-9BA6-226820C27ADD}", "3.8675740383428907E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_EOvXUN7HEdm8G6yT7-Wdqw", "_SPvXcN7IEdm8G6yT7-Wdqw", "{45219F27-0F84-4FD5-A7BC-73C19226303B}", "3.8675740383428907E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_EOvXUN7HEdm8G6yT7-Wdqw", "_SPvXcN7IEdm8G6yT7-Wdqw", "{008164B1-3AC3-47E8-9F93-EE4C36B58A97}", "3.8675740383428907E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_3lZjkCxqEdqYV4MWf8PiCw", "{45219F27-0F84-4FD5-A7BC-73C19226303B}", "3.8675740383428907E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_3aJCcN7REdmjRZts2c4ZjQ", "{D525758B-EBA2-4F59-9BA6-226820C27ADD}", "3.8675740383428907E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_Jvt1cAIaEdqEutyfYo0quQ", "_jijhYAIaEdqEutyfYo0quQ", "_mTMIkN7REdmjRZts2c4ZjQ", "{008164B1-3AC3-47E8-9F93-EE4C36B58A97}", "3.8675740383428907E-305"]}, {view: "view:_FCx1oN7CEdmsEI4YDGX2ag", path: ["_FCx1oN7CEdmsEI4YDGX2ag", "_jD8dUAIbEdqEutyfYo0quQ", "_2ClPcDIcEdqDs_9ORT1Rig", "3.8675740383428907E-305"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_mp7z0DIDEdqwaNnSEheSAg", "_4EQgMDIEEdqwaNnSEheSAg", "_SPvXcN7IEdm8G6yT7-Wdqw", "{D525758B-EBA2-4F59-9BA6-226820C27ADD}", "3.8675740383428907E-305"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_mp7z0DIDEdqwaNnSEheSAg", "_4EQgMDIEEdqwaNnSEheSAg", "_SPvXcN7IEdm8G6yT7-Wdqw", "{45219F27-0F84-4FD5-A7BC-73C19226303B}", "3.8675740383428907E-305"]}, {view: "view:_LVCagP5WEdmAzesbYywanQ", path: ["_LVCagP5WEdmAzesbYywanQ", "_mp7z0DIDEdqwaNnSEheSAg", "_4EQgMDIEEdqwaNnSEheSAg", "_SPvXcN7IEdm8G6yT7-Wdqw", "{008164B1-3AC3-47E8-9F93-EE4C36B58A97}", "3.8675740383428907E-305"]}];
					contentPage.preload(imgPath, backPath, nodeInfo,  '', false, false, false);
				</script>
</head>
<body>
<div id="breadcrumbs"></div>
<table width="100%" cellspacing="0" cellpadding="0" border="0">
<tr>
<td valign="top"><a name="Top"></a>
<div id="page-guid" value="3.8675740383428907E-305"></div>
<table width="100%" cellpadding="0" cellspacing="0" border="0">
<tr>
<td nowrap="true" class="pageTitle">Directriz: An&aacute;lisis de clase de equivalencia</td><td width="100%">
<div id="contentPageToolbar" align="right"></div>
</td>
</tr>
</table>
<table cellspacing="0" cellpadding="0" border="0" width="100%">
<tr>
<td class="pageTitleSeparator"><img height="1" title="" alt="" src="./../../../images/shim.gif"></td>
</tr>
</table>
<div class="overview">
<table cellpadding="0" cellspacing="0" border="0" width="97%">
<tr>
<td width="50"><img title="" alt="" src="./../../../images/guidance.gif"></td><td>
<table cellpadding="0" cellspacing="0" border="0" class="overviewTable">
<tr>
<td valign="top">Análisis de clase de equivalencia es una técnica para minimizar el número de casos de prueba. En esta directriz se explica lo que es esta técnica y cómo utilizarla.</td>
</tr>
</table>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Relaciones</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<th scope="row" class="sectionTableHeading">Elementos relacionados</th><td class="sectionTableCell">
<ul>
<li>
<a href="./../../../core.base_rup/tasks/identify_test_ideas_395DAB3B.html" guid="{6FAD9DF9-DE4E-4BA5-9B9B-482A2366D1B9}">Identificar ideas de prueba</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_ideas_list_2A0F8E03.html" guid="{45219F27-0F84-4FD5-A7BC-73C19226303B}">Lista de ideas de prueba</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_test_case_8AFEC963.html" guid="{D525758B-EBA2-4F59-9BA6-226820C27ADD}">Caso de prueba</a>
</li>
<li>
<a href="./../../../core.base_rup/workproducts/rup_workload_analysis_model_E86A32FF.html" guid="{008164B1-3AC3-47E8-9F93-EE4C36B58A97}">Modelo de análisis de carga de trabajo</a>
</li>
</ul>
</td>
</tr>
</table>
</div>
<div class="sectionHeading">Descripci&oacute;n principal</div>
<div class="sectionContent">
<table cellpadding="0" cellspacing="0" border="0" class="sectionTable">
<tr valign="top">
<td class="sectionTableSingleCell"><a id="Top" name="Top"></a><a id="XE_runtime_observation_amp;_analysis__concept" key="runtime observation & analysis" text="concept" name="XE_runtime_observation_&_analysis__concept" class="index"></a> 
<h3>
    <a id="Introduction" name="Introduction">Introducción</a>
</h3>
<p>
    Excepto para las aplicaciones de software más triviales, por lo general, se considera imposible probar todas las
    combinaciones de entradas factibles lógicamente para un sistema de software. Por consiguiente, seleccionar un
    subconjunto óptimo que ofrezca la máxima probabilidad de encontrar el mayor número de errores es una tarea importante y
    que vale la pena que lleven a cabo los verificadores.
</p>
<p>
    Realizar pruebas basadas en el análisis de clase de equivalencia (sinónimos: <i>partición de equivalencia</i>,
    <i>análisis de dominio</i>) es una forma de análisis de prueba de caja negra que intenta reducir el número total de
    pruebas potenciales a un conjunto mínimo de pruebas que revelan tantos errores como sea posible [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#MYE79" guid="7.755968586980351E-308">MYE79</a>]. Este método particiona el conjunto de entradas y salidas en un número finito
    de <i><a class="elementLinkWithUserText" href="./../../../core.base_rup/guidances/termdefinitions/equivalence_class_9F855392.html" guid="_yHz8QNnmEdmO6L4XMImrsA">clases
    de equivalencia</a></i> que permite seleccionar un valor de prueba representativo para cada clase. La prueba resultado
    del valor representativo para una clase es el "equivalente" a los otros valores de la misma clase. Si no se encuentra
    ningún error en la prueba del valor representativo, se estima que todos los demás valores "equivalentes" tampoco
    hubieran identificado ningún error.
</p>
<p>
    El poder de las clases de equivalencia yace en su capacidad de orientar al verificador mediante la estrategia de
    pruebas para reducir la explosión combinatoria de las pruebas potencialmente necesarias. La técnica proporciona unas
    bases lógicas por la cuales un subconjunto del número total concebible de pruebas se puede seleccionar. Aquí se
    muestran algunas categorías de áreas de problemas para grandes números de pruebas que se pueden beneficiar de la
    consideración de clases de equivalencia:
</p>
<ol>
    <li>
        Combinaciones de variables independientes
    </li>
    <li>
        Variables dependientes basadas en relaciones jerárquicas
    </li>
    <li>
        Variables dependientes basadas en relaciones temporales
    </li>
    <li>
        Relaciones en clúster basadas en ejemplares del mercado
    </li>
    <li>
        Relaciones complejas que se pueden modelar
    </li>
</ol>
<h3>
    <a id="Strategies" name="Strategies">Estrategias</a>
</h3>
<p>
    Existen técnicas y estrategias diferentes que se pueden utilizar en la prueba de partición de equivalencia. Estos son
    algunos ejemplos:
</p>
<h4>
    <a id="EquivalenceClassPartition" name="EquivalenceClassPartition">Partición de clase de equivalencia</a>
</h4>
<p>
    Teoría de partición de equivalencia tal como la propone Glenford Myers [<a class="elementLinkWithUserText" href="./../../../core.base_rup/customcategories/references_56F06DFD.html#MYE79" guid="7.755968586980351E-308">MYE79</a>]. Intenta
    reducir el número total de casos de prueba necesarios al particionar las condiciones de entrada en un número finito de
    clases de equivalencia. Se han clasificado ambos tipos de clases de equivalencia: el conjunto de entradas válidas en el
    programa se considera como la <i>clase de equivalencia válida</i>, y todas las demás entradas se incluyen en la
    <i>clase de equivalencia no válida</i>.
</p>
<p>
    A continuación se incluye un conjunto de directrices para identificar clases de equivalencia:
</p>
<ol>
    <li>
        Si una condición de entrada especifica un rango valores (por ejemplo, el programa "acepta valores de 10 a 100"), se
        identifican una clase de equivalencia válida (de 10 a 100) y dos clases de equivalencia no válidas (menor que 10 y
        mayor que 100).
    </li>
    <li>
        Si una condición de entrada especifica un conjunto de valores (por ejemplo, "la tela ser de varios colores: ROJO,
        BLANCO, NEGRO, VERDE, MARRÓN"), se identifica una clase de equivalencia válida (los valores válidos) y una clase de
        equivalencia no válida (todos los demás valores no válidos). Cada valor de la clase de equivalencia válida se debe
        manejar de modo diferente.
    </li>
    <li>
        Si la condición de entrada se especifica como una situación de obligación (por ejemplo, "la cadena de caracteres de
        entrada debe ser en mayúsculas"), se identifica una clase de equivalencia válida (caracteres en mayúsculas) y una
        clase de equivalencia no válida (todas las demás entradas excepto los caracteres en mayúsculas).
    </li>
    <li>
        Todo lo que finaliza "mucho" antes de que se lleve a cabo la tarea es una clase de equivalencia. Todo lo que se
        realiza durante un intervalo de tiempo corto antes de que finalice el programa es otra clase. Todo lo que se
        realiza antes de que el programa inicie otra operación es otra clase.
    </li>
    <li>
        Si se especifica que un programa funcione con un tamaño de memoria de 64 M a 256 M. Este rango de tamaño es una
        clase de equivalencia. Se puede aceptar cualquier otro tamaño de memoria que sea mayor que 256 M o menor que 64 M.
    </li>
    <li>
        La partición del suceso de salida se basa en las entradas del programa. Aunque clases de equivalencia de entrada
        diferentes pueden tener el mismo tipo de suceso de salida, las clases de equivalencia de entrada se deben seguir
        tratando de forma distinta.
    </li>
</ol>
<h4>
    <a id="BoundaryValueAnalysis" name="BoundaryValueAnalysis">Análisis de valor de límite</a>
</h4>
<p>
    En cada una de las clases de equivalencia, se considera que las condiciones de límite tienen un mayor índice de éxito
    en la identificación de las anomalías resultantes que las condiciones que no son de límite. Las condiciones de límite
    son los valores que se encuentran en, inmediatamente por encima o por debajo del límite o los "bordes" de cada clase de
    equivalencia.
</p>
<p>
    Las pruebas que son resultado de las condiciones de límite utilizan valores que se encuentran en el mínimo (min), justo
    encima del mínimo (min+), justo debajo del máximo (max-) y el máximo (max) del rango que se debe probar. Al probar los
    valores de límite, los verificadores eligen algunos casos de prueba para cada clase de equivalencia. Para la muestra de
    pruebas relativamente pequeña, la probabilidad de descubrimiento de anomalías es alta. Se ha reducido al verificador
    parte de la carga que supone probar una amplia población de casos en una clase de valores equivalente que es improbable
    que produzca diferencias importantes en los resultados de la prueba.
</p>
<p>
    Algunas recomendaciones al elegir valores de límite:
</p>
<ol>
    <li>
        Para una variable flotante, si la condición válida para ésta es de <code>-1.0</code> a <code>1.0</code>, probar
        <code>-1.0</code>, <code>1.0</code>, <code>-1.001</code> y <code>1.001</code>.
    </li>
    <li>
        Para un entero, si el rango de entrada válido es de <code>10</code> a <code>100</code>, probar <code>9</code>,
        <code>10</code>, <code>100</code>, <code>101</code>.
    </li>
    <li>
        Si un programa espera una letra en mayúsculas, probar de la A a la Z de límite. Probar también <code>@</code> y
        <code>[</code> puesto que, en el código ASCII, <code>@</code> está junto debajo de la A y <code>[</code> está justo
        después de la Z.
    </li>
    <li>
        Si la entrada o la salida de un programa es un conjunto ordenado, conviene prestar atención al primer y al último
        elemento del conjunto.
    </li>
    <li>
        Si la suma de las entradas debe ser un número específico (<code>n</code>), probar el programa donde la suma sea
        <code>n-1</code>, <code>n</code>, o bien, <code>n+1</code>.
    </li>
    <li>
        Si el programa acepta una lista, probar los valores de la lista. Todos los demás valores no son válidos.
    </li>
    <li>
        Al leer o escribir un archivo, comprobar los caracteres primero y último del archivo.
    </li>
    <li>
        La denominación de moneda más pequeña es un céntimo o equivalente. Si el programa acepta un rango específico, de la
        a a la b, probar a <code>-0.01</code> y b <code>+0.01</code>.
    </li>
    <li>
        Para una variable con varios rangos, cada rango es una clase de equivalencia. Si los subrangos no están solapados,
        probar los valores de los límites, después del límite superior y debajo del límite inferior.
    </li>
</ol>
<h4>
    <a id="SpecialValues" name="SpecialValues">Valores especiales</a>
</h4>
<p>
    Después de intentar las dos estrategias de análisis de límite anteriores, un verificador con experiencia puede observar
    las entradas de programa para descubrir todos los casos de "valores especiales" que, una vez más son, potencialmente,
    fuentes valiosas para revelar anomalías de software. Estos son algunos ejemplos:
</p>
<ol>
    <li>
        Para un tipo de entero, se debe probar siempre cero si se encuentra en la clase de equivalencia válida.
    </li>
    <li>
        Al probar la hora (hora, minuto y segundo), se debe probar siempre 59 y 0 como el límite superior e inferior para
        cada campo, sin tener en cuenta la restricción que tenga la variable de entrada. Así, excepto los valores de límite
        de la entrada, -1, 0, 59 y 60 siempre deben ser casos de prueba.
    </li>
    <li>
        Al probar la fecha (año, mes y día), se deben incluir numerosos casos de prueba como, por ejemplo, un número de
        días en un mes específico, el número de días de febrero en año bisiesto o el número de días en años no bisiestos.
    </li>
</ol>
<h4>
    <a id="CategoryPartition" name="CategoryPartition">Método "Categoría-Partición"</a>
</h4>
<p>
    <a href="#OstrandBalcer">Ostrand and Balcer</a> [16] han desarrollado un método de partición que ayuda a los
    desarrolladores a analizar la especificación del sistema, escribir scripts de prueba y gestionarlos. Diferente a la
    mayoría de estrategias que, básicamente, se centran en el código, su método se basa también en la información del
    diseño y la especificación.
</p>
<p>
    La principal ventaja de este método es la posibilidad de revelar errores antes de escribir el código, puesto que el
    origen de entrada es la especificación y las pruebas son resultado del análisis de dicha especificación. Las faltas en
    las especificaciones se descubren pronto, con frecuencia bastante antes de que se implementen en código.
</p>
<p>
    La estrategia del método "categoría-partición" es la siguiente:
</p>
<ol>
    <li>
        Analizar la especificación: descomponer la funcionalidad del sistema en unidades funcionales, de modo que tanto se
        puedan probar independientemente tanto por la especificación como por la implementación.<br />
         A partir de ahí:<br />
        <br />
         
        <ol>
            <li>
                Identificar los parámetros y las condiciones de entorno que van a influir en la ejecución de la función.
                Los parámetros son las entradas de la unidad de función. Las condiciones de entorno son los estados del
                sistema, que producen la ejecución de la unidad de función.
            </li>
            <li>
                Identificar las características de los parámetros y las condiciones de entorno.
            </li>
            <li>
                Clasificar las características en categorías, que producen el comportamiento del sistema.<br />
                <br />
            </li>
        </ol>En este estadio se descubren las descripciones del comportamiento ambiguas, contradictorias y que
        faltan.<br />
        <br />
    </li>
    <li>
        Particionar las categorías en opciones: Las opciones son las distintas situaciones posibles que pueden ocurrir y no
        se esperan. Representan el mismo tipo de información en una categoría.<br />
        <br />
    </li>
    <li>
        Determinar las relaciones y las restricciones entre las opciones. Las opciones de categorías diferentes influyen
        entre sí, lo que también influye en la construcción del conjunto de aplicaciones de prueba. Las restricciones se
        añaden para eliminar la contradicción entre opciones de entornos y parámetros diferentes.<br />
        <br />
    </li>
    <li>
        Diseñar casos de prueba según las categorías, las opciones y la información de las restricciones. Si una opción
        causa un error, no se debe combinar con otras opciones para crear el caso de prueba. Si una única prueba puede
        probar "suficientemente" una opción, puede ser el representante de la opción o un valor especial.
    </li>
</ol>
<h3>
    <a id="FurtherReading" name="FurtherReading">Más información y consultas</a>
</h3>
<ol>
    <li>
        Glenford J. Myers, The Art of Software Testing, John Wiley & Sons, Inc., New York, 1979.
    </li>
    <li>
        White L. J. and Cohen E. I., A domain strategy for computer program testing, IEEE Transaction on Software
        Engineering, Vol. SE-6, No. 3, 1980.
    </li>
    <li>
        Lori A. Clarke, Johnhette Hassell, and Debra J Richardson, A Close Look at Domain Testing, IEEE Transaction on
        Software Engineering, 8-4, 1992.
    </li>
    <li>
        Steven J. Zeil, Faten H. Afifi and Lee J. White, Detection of Linear Detection via Domain Testing, ACM Transaction
        on Software Engineering and Methodology, 1-4, 1992.
    </li>
    <li>
        BingHiang Jeng, Elaine J. Weyuker, A Simplified Domain-Testing Strategy, ACM Transaction on Software Engineering
        and Methodology, 3-3, 1994.
    </li>
    <li>
        Paul C. Jorgensen, Software Testing - A Craftsman's Approach, CRC Press LLC, 1995.
    </li>
    <li>
        Martin R. Woodward and Zuhoor A. Al-khanjari, Testability, fault, and the domain-to-range ratio: An eternal
        triangle, ACM Press New York, NY, 2000.
    </li>
    <li>
        Dick Hamlet, On subdomains: Testing, profiles, and components, SIGSOFT: ACM Special Interest Group on Software
        Engineering, 71-16, 2000.
    </li>
    <li>
        Cem Kaner, James Bach, and Bret Pettichord, Lessons learned in Software Testing, John Wiley & Sons, Inc., New
        York, 2002.
    </li>
    <li>
        Andy Podgurski and Charles Yang, Partition Testing, Stratified Sampling, and Cluster Analysis, SIGSOFT: ACM Special
        Interest Group on Software Engineering, 18-5, 1993.
    </li>
    <li>
        Debra J. Richardson and Lori A. Clarke, A partition analysis method to increase program reliability, SIGSOFT: ACM
        Special Interest Group on Software Engineering, 1981.
    </li>
    <li>
        Lori A. Clarke, Johnette Hassell, and Debra J Richardson, A system to generate test data and symbolically execute
        programs, IEEE Transaction on Software Engineering, SE-2, 1976.
    </li>
    <li>
        Boris Beizer, Black-Box Testing - Techniques for Functional testing of Software and System, John Wiley & Sons,
        Inc., 1995.
    </li>
    <li>
        Steven J. Zeil, Faten H. Afifi and Lee J. White, Testing for Liner Errors in Nonlinear computer programs, ACM
        Transaction on Software Engineering and Methodology, 1-4, 1992.
    </li>
    <li>
        William E. Howden, Functional Program Testing, IEEE Transactions on Software Engineering, Vol. SE-6, No. 2, 1980.
    </li>
    <li>
        <a id="OstrandBalcer" name="OstrandBalcer">Thomas J. Ostrand and Marc J. Balcer</a>, The Category-Partition method
        for specifying and generating functional tests, Communications of ACM 31, 1988.
    </li>
    <li>
        Cem Kaner, Jack Falk and Hung Quoc Nguyen, Testing Computer Software, John Wiley & Sons, Inc., 1999.
    </li>
</ol>
<p>
    &nbsp;
</p><br />
<br /></td>
</tr>
</table>
</div>
<table cellpadding="0" cellspacing="0" border="0" class="copyright">
<tr>
<td class="copyright"><p>
    &copy; &nbsp;Copyright IBM Corp.&nbsp;1987, 2006. &nbsp;Reservados todos los derechos.
</p></td>
</tr>
</table>
</td>
</tr>
</table>
</body>
<script language="JavaScript" type="text/javascript">
				contentPage.onload();
			</script>
</html>
